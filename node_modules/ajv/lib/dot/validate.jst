




{{ /**
    * schema compilation (render) time:
    * it = { schema, RULES, _validate, opts }
    * it.validate - this template function,
    *   it is used recursively to generate code for subschemas
    *
    * runtime:
    * "validate" is a variable name to which this function will be assigned
    * validateRef etc. are defined in the parent scope in index.js
    */ }}

{{
  var $async = it.schema.$async === true
    , $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref')
    , $id = it.self._getId(it.schema);
}}

{{
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
}}


  var validate = async function(data, dataPath, parentData, parentDataProperty, rootData) {
    'use strict';
    
      
    



  
  
  
    
      
    
      var  = false;
    
    
  
    
      
        return data;
      
        validate.errors = null;
        return true;
      
    
      var  = true;
    
  

  
    };
    return validate;
  

  




  {{
    var $top = it.isTop
      , $lvl = it.level = 0
      , $dataLvl = it.dataLevel = 0
      , $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;

    it.dataPathArr = [""];

    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
  }}

  var vErrors = null; 
  var errors = 0;     
  if (rootData === undefined) rootData = data; 

  {{
    var $lvl = it.level
      , $dataLvl = it.dataLevel
      , $data = 'data' + ($dataLvl || '');

    if ($id) it.baseId = it.resolve.url(it.baseId, $id);

    if ($async && !it.async) throw new Error('async schema in sync schema');
  }}

  var errs_ = errors;


{{
  var $valid = 'valid' + $lvl
    , $breakOnError = !it.opts.allErrors
    , $closingBraces1 = ''
    , $closingBraces2 = '';

  var $errorKeyword;
  var $typeSchema = it.schema.type
    , $typeIsArray = Array.isArray($typeSchema);

  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1)
        $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }

  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
}}

{{## def.checkType:
  {{
    var $schemaPath = it.schemaPath + '.type'
      , $errSchemaPath = it.errSchemaPath + '/type'
      , $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
  }}

  if () {
#}}


  
    
  
    {{
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }}
  



  



  
    
  

  
  {{? $coerceToTypes || $typeIsArray || $rulesGroup === true ||
    ($rulesGroup && !$shouldUseGroup($rulesGroup)) }}
    {{
      var $schemaPath = it.schemaPath + '.type'
        , $errSchemaPath = it.errSchemaPath + '/type';
    }}
    
      
        
      
        
      
    }
  




  
  
    }
    if (errors === 0errs_) {
    
  

  
    
      
        if () {
      
        
          
            
          
            
          
        
        
          
            
            
              
              
                
              
            
          
        
        
          
          
        
      
        }
        
          else {
            {{
              var $schemaPath = it.schemaPath + '.type'
                , $errSchemaPath = it.errSchemaPath + '/type';
            }}
            
          }
        
      

      
        if (errors === 0errs_) {
        
      
    
  


  


    
      if (errors === 0) return data;           
      else throw new ValidationError(vErrors); 
    
      validate.errors = vErrors; 
      return errors === 0;       
    
  };

  return validate;

  var  = errors === errs_;


{{
  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i=0; i < rules.length; i++)
      if ($shouldUseRule(rules[i]))
        return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined ||
           ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i=0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined)
        return true;
  }
}}
